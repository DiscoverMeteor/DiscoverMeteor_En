---
title: Errors
slug: errors
date: 0009/01/01
number: 9
points: 10
photoUrl: http://www.flickr.com/photos/ikewinski/9413892879/
photoAuthor: Mike Lewinski
contents: Create a better mechanism for displaying errors and messages.|Learn how to use `Template.rendered` to know when a user has seen an error.|Use a router filter to make sure errors are only seen once.
paragraphs: 31
---

Merely using the browser's standard `alert()` dialog to warn the user when there's problem with their submission is a bit dissatisfying, and it certainly doesn't make for great UX. We can do better. 

Instead, let's build a more versatile error reporting mechanism that will do a better job of telling the user what's going on without breaking up their flow.

### Introducing Local Collections

We are going to implement a simple system which keeps track of which errors a user has seen and displays the new ones in a "flash" area of the site. This UX pattern is useful when we want to inform a user that something has happened without disrupting their workflow too much.

What we will create is similar to the flash messages often found in Ruby on Rails apps, but is more subtle in that it's implemented client side and knows when a user has seen a message.

To start off with, we create a collection to store our errors in. Given that the errors are only relevant to the current session and don't need to be persistent in any way, we are going to do something new, and create a _local collection_. What this means is that the `Errors` collection will only exist in the browser, and will make no attempt to synchronize with the server.

To achieve this, we simply create the error in a client-only file, with the collection name set to `null`. We create a `throwError` function that simply inserts an error into our new local collection:

~~~js
// Local (client-only) collection
Errors = new Meteor.Collection(null);
~~~
<%= caption "client/helpers/errors.js" %>

Now that the collection has been created, we can add a `throwError` function which we'll call to add errors to it. We don't need to worry about `allow` or `deny` or anything like that, as this is a local collection and will not be saved to the Mongo database.

~~~js
throwError = function(message) {
  Errors.insert({message: message})
}
~~~
<%= caption "client/helpers/errors.js" %>

The advantage of using a local collection to store the errors is that, like all collections, it's reactive -- meaning we can declaratively display the errors in the same way we display any other collection data.

### Displaying errors

We are going to display the errors at the top of our main layout:

~~~html
<template name="layout">
  <div class="container">
    {{> header}}
    {{> errors}}
    <div id="main" class="row-fluid">
      {{> yield}}
    </div>
  </div>
</template>
~~~
<%= caption "client/views/application/layout.html" %>
<%= highlight "4" %>

Let's now create the `errors` and `error` templates in `errors.html`:

~~~html
<template name="errors">
  <div class="errors">
    {{#each errors}}
      {{> error}}
    {{/each}}
  </div>
</template>

<template name="error">
  <div class="alert alert-danger" role="alert">
    <button type="button" class="close" data-dismiss="alert">&times;</button>
    {{message}}
  </div>
</template>
~~~
<%= caption "client/views/includes/errors.html" %>

<% note do %>

### Twin Templates

You'll notice we're putting two templates in a single file. Up to now we've tried to adhere to a "one file, one template" convention, but as far as Meteor is concerned putting all our templates in a single file works just as well (although it would make for a very confusing `main.html`!).

In this case, since both error templates are fairly short, we'll make an exception and put them in the same file to make our repo a bit cleaner. 

<% end %>

We just need to integrate our template helper, and we'll be good to go!

~~~js
Template.errors.helpers({
  errors: function() {
    return Errors.find();
  }
});
~~~
<%= caption "client/views/includes/errors.js" %>

<%= commit "9-1", "Basic error reporting." %>

### Creating errors

We now know how to display errors, but we still need to create some before we'll see anything. Errors are most commonly triggered by users entering new content, so we'll check for errors in our post creation callback, and display a message for any errors that get raised.

In addition, if we get the `302` error (which indicates that a post with the same URL already exists), we'll redirect the user to the existing post. We obtain the existing post's `_id` from `error.details` (remember we passed that post's `_id` as the third `details` argument of our `Error` class in chapter 7). 

~~~js
Template.postSubmit.events({
  'submit form': function(e) {
    e.preventDefault();
    
    var post = {
      url: $(e.target).find('[name=url]').val(),
      title: $(e.target).find('[name=title]').val(),
      message: $(e.target).find('[name=message]').val()
    }
    
    Meteor.call('post', post, function(error, id) {
      if (error) {
        // display the error to the user
        throwError(error.reason);
        
        if (error.error === 302)
          Router.go('postPage', {_id: error.details})
      } else {
        Router.go('postPage', {_id: id});
      }
    });
  }
});
~~~
<%= caption "client/views/posts/post_submit.js" %>
<%= highlight "12~14, 16~21" %>

<%= commit "9-2", "Actually use the error reporting." %>

Give it a try: try creating a post and entering the URL `http://meteor.com`. As this URL is already attached to a post in the fixtures, you should see:

<%= screenshot "9-1", "Triggering an error" %>

### Clearing Errors

// FIXME: this text is wrong.

If you click the error's close button at this point, you'll see the error disappear, because that close button triggers Twitter Bootstrap's embedded JavaScript. 

But while Bootstrap is removing the error `<div>` from the DOM, it's not removing the error object from the Meteor collection. So let's add a way to clean up our local collection once an error has done its job. 

First, we'll modify the `throwError` function to include a `seen` property. This will be useful later on to keep track of whether an error has been actually seen by the user. 

Once that's done, we can code up a simple `clearErrors` function that clears those "seen" errors:


In order for our `clearErrors()` function to do its job, errors need to be marked as `seen`. To do this properly, there's one edge case we need to take care of: when we throw up an error and then redirect the user somewhere else (as we do when they try to post a duplicate link), the redirection happens instantly. This means that the user never has the chance to actually see the error before it's cleared. 

This is where our `seen` property will come in handy. We need to ensure that it's only set to `true` if the user has actually seen the error. 

To achieve this, we'll use `Meteor.defer()`. This function tells Meteor to execute its callback "just after" whatever's going on now. If it helps, you can consider that `defer()` is like telling the browser to wait 1 millisecond before proceeding. 

What we're doing is telling Meteor to set `seen` to `true` 1 millisecond after the `errors` template has been rendered. But remember how we said that redirection happens instantly? This means that the redirection will kick in before the `defer` callback, which will never have a chance to be executed.

This is exactly what we want: if it's not executed our error will not be marked as `seen`, which means it won't be cleared, which means it'll appear on the page our user is redirected to just like we wanted!

~~~js
Template.errors.helpers({
  errors: function() {
    return Errors.find();
  }
});

Template.error.rendered = function() {
  var error = this.data;
  Meteor.setTimeout(function () {
    Errors.remove(error._id);
  }, 3000);
};
~~~
<%= caption "client/views/includes/errors.js" %>
<%= highlight "7~12" %>

<%= commit "9-3", "Monitor which errors have been seen, and clear on routing." %>

The `rendered` callback triggers once our template has been rendered in the browser. Inside the callback, `this` refers to the current template instance, and `this.data` lets us access the data of the object that is currently being rendered (in our case, an error).

Whew! That was a lot of work for something users will hopefully never see!


### Seeking Validation

We need to enforce some kind of validation on our form. At the minimum, we'll want users to provide both a URL and a title for their new post. 

We'll do two things to point out any missing fields: first, we'll give a special `has-error` CSS class to the parent `div` of any problematic form field. Second, we'll display a helpful error message just below the field.

To get started, let's prep our `postSubmit` template to accept these new helpers:

~~~html
<template name="postSubmit">
  <form class="main form">
    <div class="form-group {{errorClass 'url'}}">
      <label class="control-label" for="url">URL</label>
      <div class="controls">
          <input name="url" id="url" type="text" value="" placeholder="Your URL" class="form-control"/>
          <span class="help-block">{{errorMessage 'url'}}</span>
      </div>
    </div>
    <div class="form-group {{errorClass 'title'}}">
      <label class="control-label" for="title">Title</label>
      <div class="controls">
          <input name="title" id="title" type="text" value="" placeholder="Name your post" class="form-control"/>
          <span class="help-block">{{errorMessage 'title'}}</span>
      </div>
    </div>
    <input type="submit" value="Submit" class="btn btn-primary"/>
  </form>
</template>
~~~
<%= caption "client/views/posts/post_submit.html" %>
<%= highlight "3,7,10,14" %>

Note that we're passing parameters (`url` and `title` respectively) to each helper. This lets us reuse the same helper both time, modifying its behavior based on the parameter.

Now for the fun part: making these helpers actually do something.

We'll use the **Session** to store a `postSubmitErrors` object containing any potential error message. As the user interacts with the form, this object will change, which in turn will reactively update the form's markup and contents.

~~~js
Template.postSubmit.created = function() {
  Session.set('postSubmitErrors', {});
}

Template.postSubmit.helpers({
  errorMessage: function(field) {
    return Session.get('postSubmitErrors')[field];
  },
  errorClass: function (field) {
    return !!Session.get('postSubmitErrors')[field] ? 'has-error' : '';
  }
});

validatePost = function (post) {
  var errors = {};

  if (!post.title)
    errors.title = "Please fill in a headline";
  
  if (!post.url)
    errors.url =  "Please fill in a URL";

  return errors;
}

Template.postSubmit.events({
  'submit form': function(e) {
    e.preventDefault();
    
    var post = {
      url: $(e.target).find('[name=url]').val(),
      title: $(e.target).find('[name=title]').val()
    };
    
    var errors = validatePost(post);
    if (errors.title || errors.url)
      return Session.set('postSubmitErrors', errors);
    
    post._id = Posts.insert(post);
    Router.go('postPage', post);
  }
});
~~~
<%= caption "client/views/posts/post_submit.js" %>
//and highlight

[SACHA - I put the validate post function in here to begin with as it doesn't yet make sense to generalize it -- does it?]